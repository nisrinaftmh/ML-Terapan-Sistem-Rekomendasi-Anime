# -*- coding: utf-8 -*-
"""Proyek Kedua ML Terapan_ MC006D5X1393.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mhoTSw6GuOF7wWhIBlmIYzQ0IXn62u51

# Recommendation System : Sistem Rekomendasi Anime berdasarkan Genre

Nama : Nisrina Fatimah Parisya


ID Cohort :MC006D5X1393

## Data Loading

Pada tahapan pertama, saya mengambil dataset dari website Kaggle dengan nama ***Anime Data*** dan menggunakan library pandas serta menggunakan fungsi` read_csv()` untuk mengunggah dataset yang akan di proses.

Dataset ini terdiri dari 1563 baris dan 20 kolom dimana 16 kolom tersebut memiliki tipe data object, 1 kolom bertipe data float dan 3 kolom bertipe data integer.
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("canggih/anime-data-score-staff-synopsis-and-genre")

print("Path to dataset files:", path)

!pip install fuzzywuzzy
!pip install -q sentence-transformers fuzzywuzzy

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MultiLabelBinarizer, StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack
from fuzzywuzzy import fuzz
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv("/kaggle/input/anime-data-score-staff-synopsis-and-genre/dataanime.csv")
df.head()

"""## Data Understanding

Dataset yang digunakan merupakan dataset berjudul "Anime Data"  yang dapat diakses melalui kaggle dengan link berikut ini [Anime Data](https://www.kaggle.com/datasets/canggih/anime-data-score-staff-synopsis-and-genre). Dataset ini terdiri dari 1563 Baris dengan berisi judul-judul anime beserta variabel pendukung yang relevan, sehingga cocok untuk memberikan rekomendasi judul anime sejenis berdasarkan genre yang disukai pengguna.

**Kondisi Data**
* Ada kolom bertipe objek seperti:
`Title, Type, Episodes, Status, Start airing, End airing, Starting season, Broadcast time, Producers, Licensors, Studios, Sources, Genres, Duration, Rating, Score, Scored by, Members, Favorites, Description.`
* Ada juga kolom bertipe numerik:
`Score (float64), dan Scored by, Members, Favorites (int64).`
* Tidak ditemukan duplicate data pada 1563 baris dan 20 kolom data.
* Terdapat missing value pada kolom Rating sebanyak 9 baris

**Fitur yang terdapat pada setiap kolom dataset**:

| Kolom             | Deskripsi                                                                                        |
|-------------------|--------------------------------------------------------------------------------------------------|
| Title             | Nama resmi anime sebagai identitas utama                                                       |
| Type              | Jenis format anime seperti TV, Movie, OVA, dll                                                   |
| Episodes          | Jumlah total episode dalam anime tersebut                                                          |
| Status            | Status penayangan anime saat ini (selesai, tayang, atau belum)                                    |
| Start airing      | Tanggal mulai anime ditayangkan                                                                      |
| End airing        | Tanggal anime selesai tayang                                                                         |
| Starting season   | Musim dan tahun saat anime mulai tayang                                                             |
| Broadcast time    | Waktu penayangan anime di TV                                                                         |
| Producers         | Perusahaan atau pihak yang memproduksi anime                                                         |
| Licensors         | Pihak yang memegang lisensi tayang anime di luar Jepang                                                   |
| Studios           | Studio animasi yang membuat anime tersebut                                                             |

**Insight**

### Exploratory Data Analysis (EDA)

Tahapan ini dilakukan untuk memahami isi dataset. hal pertama yang dilakukan adalah memahami dan mengecek isi dari dataset dengan menggunakan `.shape', .info() `dan `.describe()`
"""

df.shape

"""Dalam Cell diatas ini dapat kita ketahui bahwa dataset terdiri dari 1563 barus data dengan 20 kolom"""

df.info()

"""Berdasarkan output tersebut kita dapat mengetahui ada beberapa jenis data:

* 16 Kolom dengan tipe data object yang termasuk dalam kategori kategorikal atau teks, contohnya: Title, Type, Status, Start airing, Genres, Studios, Description, dll.
Kolom-kolom ini berisi informasi non-numerik seperti judul anime, tipe (TV/Movie), studio produksi, atau deskripsi.

* 1 Kolom dengan tipe data float64 yang termasuk dalam kategori numerik, yaitu:
Score: nilai rating anime dalam bentuk desimal (contoh: 8.52)

* 3 Kolom dengan tipe data int64 yang juga termasuk kategori numerik, yaitu: Scored by, Members, dan Favorites, ketiganya menunjukkan jumlah vote, jumlah member, dan jumlah favorit dalam angka bulat.

##### Pengecekan Missing Value

pada tahapan ini kita dapat melakukan pengecekan missing value dalam dataset tersebut diantaranya menggunakan fungsi .`isnull().sum()` untuk mengetahui missing value di setiap kolom
"""

# Jumlah nilai yang hilang per kolom
missing_values = df.isnull().sum()
print("Cek Missing Value:")
missing_values

"""Berdasarkan output diatas ditemukan adanya missing value pada kolom rating sebanyak 9 baris sehingga pada bagian Data Preparation nantinya akan dilakukan Handling Missing Value.

##### Pengecekan Duplikasi Data

Pada tahapan ini kita dapat melakukan pengecekan duplikasi data dengan df.`duplicated().sum(). `Setelah melakukan pengecekan ternyata terdapat data yang mengalami duplikasi sebanyak 2 duplikasi data.
"""

# cek duplikasi data
duplicated_rows = df.duplicated().sum()
print(f"Jumlah baris duplikat: {duplicated_rows}")

if duplicated_rows > 0:
    print("\nBaris duplikat:")
    print(df[df.duplicated()])
else:
    print("\nTidak ada baris duplikat.")

"""##### Cek Statistik Deskriptif Dataset"""

df.describe()

"""Berdasarkan output tersebut kita dapat melakukan identifikais berupa :

* Score: Rata-rata 7.90 dengan rentang 7.48–9.25. Nilainya cenderung tinggi dan stabil karena anime yang masuk dataset umumnya sudah populer.

* Scored by: Rata-rata dinilai oleh 605 ribu user, dengan maksimum hampir 1 juta. Menunjukkan variasi popularitas antar anime.

* Members: Rata-rata 115 ribu orang menambahkan ke daftar tontonan, dengan maksimum 1,4 juta.

* Favorites: Rata-rata 2.300 favorit, tapi bisa mencapai lebih dari 100 ribu untuk anime yang sangat disukai.

* Nilai-nilai tinggi ini wajar karena data berasal dari pengguna nyata dan bersifat natural.

##### Unvariate Analysis
"""

df['Score'] = pd.to_numeric(df['Score'], errors='coerce')

# Menghitung rata-rata score
average_score = df['Score'].mean()

plt.figure(figsize=(10, 6))
sns.histplot(df['Score'].dropna(), bins=30, kde=True, color='skyblue')
plt.axvline(average_score, color='red', linestyle='dashed', linewidth=2, label=f'Rata-rata Score: {average_score:.2f}')
plt.title('Distribusi Score Anime')
plt.xlabel('Score')
plt.ylabel('Frekuensi')
plt.legend()
plt.grid(True)
plt.show()

"""Kode ini bertujuan untuk menganalisis dan menampilkan distribusi skor anime dalam bentuk histogram. Pertama, kolom 'Score' diubah ke format numerik menggunakan `pd.to_numeric() `untuk memastikan data dapat diolah secara matematis. Kemudian dihitung nilai rata-rata skor menggunakan fungsi `mean()`. Visualisasi dibuat dengan `sns.histplot()` yang menghasilkan histogram. Garis merah putus-putus ditambahkan menggunakan `plt.axvline()` untuk menandai posisi rata-rata skor pada grafik."""

# Mengambil data genre
genres = df['Genres'].dropna()

# Memisahkan genre yang dipisahkan koma dan menghitung frekuensinya
all_genres = [genre.strip() for genres_list in genres for genre in genres_list.split(',')]
genre_counts = pd.Series(all_genres).value_counts()

# Mengambil 20 genre teratas
top_genres = genre_counts.head(20)

# Membuat diagram batang
plt.figure(figsize=(14, 8))
sns.barplot(x=top_genres.index, y=top_genres.values, palette='viridis')
plt.title('Distribusi Genre Anime Teratas')
plt.xlabel('Genre')
plt.ylabel('Jumlah Anime')
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

"""Kode ini digunakan untuk menganalisis dan menampilkan genre anime yang paling populer dalam dataset. Pertama, data genre diambil dari kolom 'Genres' sambil menghilangkan nilai kosong. Karena satu anime bisa punya beberapa genre yang dipisah koma, kode ini memecah setiap daftar genre dan membersihkannya, lalu menyusunnya dalam satu list. Kemudian dihitung berapa kali setiap genre muncul menggunakan` value_counts()` dan diambil 20 genre teratas saja."""

# Distribusi 'Scored By' dan 'Members'
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
sns.histplot(df['Scored by'], bins=30, kde=True, color='salmon')
plt.title('Distribusi Scored By')
plt.xlabel('Jumlah Pemberi Skor')
plt.ylabel('Frekuensi')

plt.subplot(1, 2, 2)
sns.histplot(df['Members'], bins=30, kde=True, color='lightgreen')
plt.title('Distribusi Members')
plt.xlabel('Jumlah Member')
plt.ylabel('Frekuensi')

plt.tight_layout()
plt.show()

"""Kode ini digunakan untuk membandingkan distribusi jumlah pemberi skor dan member anime. Grafik pertama menunjukkan histogram distribusi 'Scored by' (jumlah orang yang memberi rating). Grafik kedua menunjukkan distribusi 'Members' (jumlah anggota yang mengikuti anime).Fungsi `tight_layout() `memastikan kedua grafik tidak saling bertabrakan dan tertata rapi. Hasilnya adalah visualisasi yang membantu melihat pola sebaran popularity anime berdasarkan dua metrik mengenai seberapa banyak orang yang menilai dan seberapa banyak yang mengikuti anime tersebut.

##### Multivariate
"""

# Mengambil kolom 'Genres' dan 'Score' dan menghilangkan baris dengan nilai yang hilang pada kedua kolom tersebut
df_genre_score = df[['Genres', 'Score']].dropna()

# Memisahkan genre-genre dan membuat dataframe baru
genre_list = df_genre_score['Genres'].str.split(',', expand=True).stack()
genre_list = genre_list.str.strip()

# Menggabungkan kembali dengan skor
df_expanded = pd.DataFrame({'Genre': genre_list.values, 'Score': df_genre_score['Score'].repeat(df_genre_score['Genres'].str.split(',').apply(len)).values})

# Membuat pivot table untuk menghitung rata-rata skor per genre
genre_score_pivot = df_expanded.pivot_table(values='Score', index='Genre', aggfunc='mean')

# Mengurutkan genre berdasarkan rata-rata skor
genre_score_pivot_sorted = genre_score_pivot.sort_values(by='Score', ascending=False)

# Membuat heatmap
plt.figure(figsize=(10, 15))
sns.heatmap(genre_score_pivot_sorted, annot=True, fmt=".2f", cmap="YlGnBu", cbar_kws={'label': 'Rata-rata Skor'})
plt.title('Distribusi Rata-rata Skor per Genre', fontsize=16)
plt.xlabel('Rata-rata Skor', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

"""Kode ini menganalisis rata-rata skor setiap genre anime dengan memecah genre yang terpisah koma menggunakan s`tr.split() dan stack()` `Inline code`menjadi baris individual. Setiap genre dipasangkan dengan skor anime aslinya menggunakan `repeat()`, kemudian dihitung rata-rata skor per genre dengan `pivot_table().` Data diurutkan dari skor tertinggi ke terendah dan divisualisasikan menggunakan `sns.heatmap()` yang menunjukkan genre mana yang cenderung mendapat rating terbaik dari penonton.

## Data Preparation

##### Handling Missing Value

Sebagaimana setelah melakukan pengecekan data dapat kita lihat bahwa ada 9 data yang mengalami missing value sehingga diperlukan adanya penghapusan data duplikat menggunakan fungsi `df.isnull().sum()`
"""

missing_values_after = df.isnull().sum()
print("Missing values after potential handling:")
missing_values_after

"""#### Text Preprocessing

Pada tahap ini saya membuat fungsi clean_title() untuk membersihkan judul anime dari karakter khusus menggunakan re.sub() dengan regex pattern yang hanya menyisakan huruf, angka, dan spasi. Fungsi ini diterapkan ke seluruh kolom 'Title' menggunakan apply() untuk menghilangkan simbol-simbol seperti tanda baca, karakter unicode, atau tanda khusus lainnya. Hasilnya adalah judul yang lebih bersih dan konsisten untuk analisis lebih lanjut.
"""

import re

def clean_title(title):
    if isinstance(title, str):
        cleaned_title = re.sub(r'[^a-zA-Z0-9\s]', '', title)
        return cleaned_title.strip()
    else:
        return title

df['Title'] = df['Title'].apply(clean_title)

# Contoh output setelah dibersihkan
print("\nContoh Judul Setelah Dibersihkan:")
print(df['Title'].head())

"""#### Pengelompokan Tipe Data

pada tahapan ini saya mengecek tipe data terhadap kolom yang akan di gunakan untuk permodelan, disini saya menggunakan `df.select_dtypes(include=['number']).columns.tolist()` dan `df.select_dtypes(include=['object']).columns.tolist()`. dapat dilihat pada output dibawah kode tersebut apa saja kolom dengan tipe data numerik dam kolom dengan data kategorikal
"""

# Mengecek tipe data setiap kolom dan mengelompokkannya
num_col = df.select_dtypes(include=['number']).columns.tolist()
cat_col = df.select_dtypes(include=['object']).columns.tolist()

print("Kolom Numerikal:")
print(num_col)
print("\nKolom Kategorikal:")
print(cat_col)

"""## Modeling

#### Content-based Filtering

Pada tahapan modeling ini, akan digunakan sistem rekomendasi berdasarkan pendekatan Content-Based Filtering dimana nantinya sistem akan merekomendasikan judul anime dyang memiliki kesamaan genre dengan judul anime yang diinginkan oleh user. Sistem akan menampilkan 5 judul anime dengan kemiripan genre yang sama dengan judul anime pilihan pengguna.

#### TF-IDF

TF-IDF pada tahapan ini digunakan untuk mengubah teks pada kolom genre menjadi angka dengan memberikan bobot tinggi pada genre yang jarang muncul dan bobot rendah pada genre yang umum, sehingga bisa mengidentifikasi keunikan setiap anime berdasarkan kombinasi genrenya.

**TF-IDF Vectorizer dan DataFrame Conversion**

**TF-IDF Vectorizer dan DataFrame Conversion** adalah proses lengkap yang meliputi inisialisasi TF-IDF vectorizer, training dengan data genre, ekstraksi fitur, transformasi teks menjadi matrix numerik, dan konversi ke format DataFrame pandas untuk analisis yang lebih mudah. Proses ini mengubah data teks genre yang tidak terstruktur menjadi representasi numerik yang dapat digunakan untuk machine learning dan analisis data.

Proses Kerja Konversi:

- **Vectorizer Initialization**: Menginisialisasi TfidfVectorizer dengan konfigurasi default untuk memproses data teks genre
- **Training Process**: Melatih vectorizer dengan data genre menggunakan fit() untuk membangun vocabulary dan menghitung IDF values
- **Feature Extraction**: Mengekstraksi nama-nama fitur yang telah dipelajari dari corpus menggunakan get_feature_names_out()
- **TF-IDF Transformation**: Mengubah teks genre menjadi sparse matrix TF-IDF menggunakan fit_transform()
- **Dense Conversion**: Mengkonversi sparse matrix menjadi dense matrix menggunakan todense()
- **DataFrame Creation**: Membuat DataFrame pandas dengan kolom sebagai fitur dan baris sebagai dokumen
- **Sampling**: Mengambil sample data secara acak untuk visualisasi dan analisis

Parameter:

- **vectorizer**: TfidfVectorizer() dengan parameter default
- **training_data**: df['Genres'] sebagai input untuk pembelajaran vocabulary
- **tfidf_matrix**: Sparse matrix hasil transformasi TF-IDF
- **dense_data**: tfidf_matrix.todense() untuk konversi ke format dense
- **columns**: vectorizer.get_feature_names_out() sebagai nama kolom DataFrame
- **index**: df['Title'] untuk identifikasi setiap dokumen/film
- **sample_size**: min(15, len(tfidf_dataframe)) untuk kolom dan min(8, len(tfidf_dataframe)) untuk baris

Tahapan Penyusunan Model:

1. **Inisialisasi**: TfidfVectorizer() dipanggil untuk membuat instance vectorizer dengan konfigurasi default
2. **Training**: vectorizer.fit(df['Genres']) melatih model dengan data genre untuk membangun vocabulary dan menghitung IDF
3. **Feature Extraction**: get_feature_names_out() mengekstraksi nama fitur yang telah dipelajari dari corpus
4. **Matrix Creation**: fit_transform(df['Genres']) mengubah data genre menjadi sparse matrix TF-IDF
5. **Dense Conversion**: todense() mengkonversi sparse matrix menjadi dense matrix untuk kompatibilitas DataFrame
6. **DataFrame Construction**: pd.DataFrame() membuat DataFrame dengan dense matrix sebagai data, feature names sebagai kolom, dan titles sebagai index
7. **Sampling**: sample() digunakan untuk mengambil subset data secara acak untuk visualisasi

Kelebihan:

- **Efisiensi Pemrosesan**: TF-IDF memberikan representasi numerik yang efektif untuk data teks genre
- **Vocabulary Learning**: Secara otomatis membangun vocabulary dari corpus tanpa preprocessing manual
- **Feature Interpretability**: Nama fitur yang diekstraksi mudah dipahami dan diinterpretasikan
- **DataFrame Compatibility**: Format DataFrame memudahkan visualisasi, filtering, dan manipulasi data
- **Sampling Flexibility**: Kemampuan sampling memungkinkan eksplorasi data besar dengan efisien
- **Integration Ready**: Siap diintegrasikan dengan algoritma machine learning dan analisis lanjutan

Kekurangan:

- **Memory Intensive**: Konversi ke dense matrix dan DataFrame menggunakan memori yang sangat besar
- **Performance Impact**: Proses todense() dapat lambat untuk dataset dengan dimensi tinggi
- **Sparse Matrix Loss**: Kehilangan efisiensi sparse matrix dalam hal storage dan komputasi
- **Scalability Issues**: Tidak scalable untuk dataset dengan jutaan dokumen atau fitur
- **Redundant Processing**: fit_transform() dipanggil dua kali yang menyebabkan pemrosesan berulang
- **Limited Semantic Understanding**: TF-IDF tidak menangkap hubungan semantik antar kata dalam genre

Implementasi:

- **Vectorizer Setup**: TfidfVectorizer() diinisialisasi dengan parameter default untuk fleksibilitas maksimal
- **Model Training**: vectorizer.fit() dan fit_transform() digunakan untuk pembelajaran dan transformasi data genre
- **Feature Analysis**: get_feature_names_out() mengekstraksi dan menampilkan fitur-fitur genre yang telah dipelajari
- **Matrix Conversion**: todense() mengkonversi sparse matrix menjadi dense untuk kompatibilitas DataFrame
- **DataFrame Creation**: pd.DataFrame() membuat struktur tabular dengan titles sebagai index dan features sebagai kolom
- **Data Sampling**: sample() dengan parameter axis=0 dan axis=1 mengambil subset baris dan kolom secara acak untuk preview
- **Visualization Ready**: Hasil akhir berupa DataFrame yang siap untuk analisis, visualisasi, dan pemrosesan lebih lanjut
"""

# Inisialisasi dan Training TF-IDF Vectorizer
vectorizer = TfidfVectorizer()

# Melatih vectorizer dengan data genre
vectorizer.fit(df['Genres'])

# Melihat fitur yang telah diekstraksi
feature_names = vectorizer.get_feature_names_out()
print(f"Jumlah fitur genre: {len(feature_names)}")
print("Contoh fitur genre:")
print(feature_names[:20])

# Mengubah teks genre menjadi representasi numerik TF-IDF
tfidf_matrix = vectorizer.fit_transform(df['Genres'])
print(f"Dimensi TF-IDF matrix: {tfidf_matrix.shape}")

# Konversi ke DataFrame untuk visualisasi yang lebih baik
tfidf_dataframe = pd.DataFrame(
    tfidf_matrix.todense(),
    columns=vectorizer.get_feature_names_out(),
    index=df['Title']
)

# Menampilkan sample dari matrix TF-IDF
print("Sample TF-IDF Matrix:")
sample_df = tfidf_dataframe.sample(n=min(15, len(tfidf_dataframe)), axis=1).sample(n=min(8, len(tfidf_dataframe)), axis=0)
sample_df

"""#### Cosine Similarity

**Cosine Similarity Matrix Computation** adalah proses perhitungan kesamaan antar dokumen (anime) berdasarkan representasi TF-IDF genre menggunakan metrik cosine similarity, kemudian mengkonversinya menjadi DataFrame untuk analisis dan visualisasi yang lebih mudah. Proses ini menghasilkan matrix simetris yang menunjukkan tingkat kesamaan genre antar anime dengan nilai berkisar dari 0 (tidak sama) hingga 1 (identik).

Proses Kerja Perhitungan:

- Matrix Input Processing: Menggunakan TF-IDF matrix sebagai input untuk perhitungan cosine similarity
- Cosine Calculation: Menghitung cosine angle antara setiap pasangan vector anime dalam ruang TF-IDF
- Similarity Matrix Generation: Membuat matrix simetris n×n dimana n adalah jumlah anime
- Normalization: Hasil similarity dinormalisasi dalam rentang 0-1 berdasarkan cosine angle
- DataFrame Conversion: Mengkonversi numpy array menjadi DataFrame pandas dengan proper indexing
- Index Assignment: Menetapkan nama anime sebagai index dan column untuk kemudahan identifikasi
- Sampling Process: Mengambil subset matrix secara acak untuk visualisasi dan analisis

Parameter:

- input_matrix: tfidf_matrix sebagai basis perhitungan similarity
- similarity_function: cosine_similarity dari sklearn.metrics.pairwise
- output_shape: (n_samples, n_samples) matrix simetris
- data_source: similarity_matrix hasil perhitungan cosine
- index_columns: df['Title'] untuk penamaan baris dan kolom DataFrame
- sample_parameters: min(6, len(similarity_df)) untuk kolom dan min(8, len(similarity_df)) untuk baris
- similarity_range: nilai antara 0.0 hingga 1.0

Tahapan Penyusunan Model:

- Input Preparation: TF-IDF matrix yang telah dibuat sebelumnya digunakan sebagai input untuk perhitungan similarity
- Cosine Computation: cosine_similarity(tfidf_matrix) menghitung kesamaan cosine antar semua pasangan anime
- Matrix Validation: Memeriksa dimensi similarity matrix untuk memastikan hasil perhitungan benar
- DataFrame Construction: pd.DataFrame() mengkonversi similarity matrix menjadi format DataFrame
- Index Setting: df['Title'] digunakan sebagai index dan columns untuk identifikasi anime
- Dimension Verification: Memeriksa shape DataFrame untuk konfirmasi struktur data
Sample Generation: sample() digunakan untuk mengambil subset matrix secara acak untuk preview dan analisis

Kelebihan:

- Matrix similarity yang dihasilkan bersifat simetris dan konsisten
- Normalized Values: Nilai similarity dalam rentang 0-1 yang mudah diinterpretasikan
- Menghitung similarity untuk semua pasangan anime sekaligus
- DataFrame Integration: Format DataFrame memudahkan filtering, sorting, dan analisis data
-Sampling memungkinkan preview data besar tanpa load seluruh matrix
-  Hasil dapat langsung digunakan untuk sistem rekomendasi


Kekurangan:

- Membutuhkan memory O(n²) untuk menyimpan full similarity matrix
- Perhitungan cosine untuk semua pasangan bisa lambat pada dataset besar
- Matrix simetris menyimpan informasi duplikat (upper dan lower triangle)
- Menggunakan dense matrix yang tidak efisien untuk sparse similarity
- Tidak scalable untuk dataset dengan puluhan ribu anime
- Hanya mempertimbangkan genre tanpa faktor lain seperti rating atau tahun
- Tidak menangkap nuansa atau bobot relatif antar genre

Implementasi:

- Similarity Calculation: cosine_similarity(tfidf_matrix) menghitung kesamaan berdasarkan angle antar vector TF-IDF
- Matrix Shape Validation: Menampilkan shape matrix untuk verifikasi bahwa hasil perhitungan sesuai ekspektasi
- DataFrame Transformation: pd.DataFrame() dengan parameter similarity_matrix, index, dan columns untuk struktur data yang rapi
- Dual Indexing: Menggunakan df['Title'] sebagai index dan columns untuk kemudahan cross-reference anime
- Dimension Display: Menampilkan shape DataFrame untuk konfirmasi struktur dan ukuran data
- Random Sampling: sample() dengan axis=0 dan  axis=1 untuk mengambil subset baris dan kolom secara acak
- Preview Generation: Menghasilkan sample similarity matrix yang representatif untuk analisis awal dan validasi hasil
"""

# Menghitung kesamaan cosine antar anime berdasarkan genre
similarity_matrix = cosine_similarity(tfidf_matrix)
print(f"Shape similarity matrix: {similarity_matrix.shape}")

# Mengubah similarity matrix menjadi DataFrame dengan index dan kolom nama anime
similarity_df = pd.DataFrame(
    similarity_matrix,
    index=df['Title'],
    columns=df['Title']
)

print(f'Dimensi similarity dataframe:')
similarity_df.shape

# Melihat contoh similarity matrix
print("\nContoh Similarity Matrix:")
sample_similarity = similarity_df.sample(n=min(6, len(similarity_df)), axis=1).sample(n=min(8, len(similarity_df)), axis=0)
sample_similarity

"""#### Membuat Fungsi Sistem Rekomendasi Anime

Pada tahapan ini saya membuat fungsi rekomendasi anime yang mengimplementasikan sistem rekomendasi berbasis content-based filtering menggunakan cosine similarity untuk memberikan rekomendasi anime berdasarkan kesamaan genre.

Fungsi ini mengambil input anime tertentu dan mengembalikan daftar anime yang memiliki genre paling mirip berdasarkan perhitungan similarity matrix yang telah dibuat sebelumnya.

Proses Kerja Rekomendasi:

- Input Validation: Mengecek keberadaan anime yang diminta dalam dataset similarity matrix
- Similarity Extraction: Mengambil row similarity scores untuk anime target dari  similarity DataFrame
- Array Conversion: Mengkonversi pandas Series menjadi numpy array untuk operasi numerik yang efisien
- Top-N Selection: Menggunakan argpartition untuk mendapatkan indices dengan similarity score tertinggi
- Index Filtering: Menghapus anime input dari hasil rekomendasi untuk menghindari self-recommendation
- Data Merging: Menggabungkan hasil rekomendasi dengan informasi lengkap anime (genre, score)
Score Integration: Menambahkan similarity score ke dalam hasil final untuk transparansi

Parameter:

- anime_title: string nama anime yang menjadi basis rekomendasi
- similarity_data: similarity_df sebagai source matrix kesamaan (default)
- anime_data: df[['Title', 'Genres', 'Score']] untuk informasi lengkap anime
- num_recommendations: integer jumlah rekomendasi yang diinginkan (default=5)
- similarity_scores: numpy array hasil konversi dari pandas Series
- top_indices: hasil argpartition untuk indices dengan similarity tertinggi
- recommended_titles: pandas Index berisi nama-nama anime yang direkomendasikan

Tahapan Penyusunan Model:

- Input Validation: Mengecek apakah anime_title ada dalam similarity_data.index menggunakan conditional check
- Data Extraction: similarity_data.loc[anime_title].to_numpy() mengambil dan mengkonversi similarity scores
- Efficient Sorting: argpartition() digunakan untuk mendapatkan top-k indices tanpa full sorting
- Index Selection: Slicing dengan [-1:-(num_recommendations+2):-1] untuk mengambil indices dengan similarity tertinggi
- Title Mapping: similarity_data.columns[most_similar_indices] mengkonversi indices menjadi nama anime
- Self-Removal: drop(anime_title, errors='ignore') menghapus anime input dari hasil rekomendasi
- Data Integration: merge() menggabungkan recommended titles dengan informasi lengkap anime
- Score Addition: List comprehension menambahkan similarity score untuk setiap rekomendasi

Kelebihan:

- Fast Retrieval: Menggunakan argpartition yang lebih efisien dibanding full sorting untuk top-n selection
- Robust Error Handling: Menangani kasus anime tidak ditemukan dengan pesan error yang informatif
- Comprehensive Output: Mengembalikan informasi lengkap termasuk genre, score, dan similarity score
- Flexible Parameters: Mendukung kustomisasi jumlah rekomendasi dan data source
- Self-Exclusion: Otomatis menghapus anime input dari hasil rekomendasi
- Transparent Scoring: Menyertakan similarity score untuk evaluasi kualitas rekomendasi
- Memory Efficient: Tidak memuat seluruh dataset ke memory, hanya mengakses data yang diperlukan

Kekurangan:

- Single Criteria: Hanya berdasarkan similarity genre, tidak mempertimbangkan faktor lain
- Cold Start Problem: Tidak dapat memberikan rekomendasi untuk anime baru yang tidak ada dalam dataset
- Genre Bias: Terlalu bergantung pada representasi genre yang mungkin tidak akurat
- No Personalization: Tidak mempertimbangkan preferensi individual pengguna

Implementasi:

- Function Definition: get_anime_recommendations() dengan parameter yang fleksibel dan default values
- Existence Check: Conditional statement untuk validasi keberadaan anime dalam similarity matrix
- Efficient Computation: Kombinasi to_numpy(), argpartition(), dan slicing untuk operasi yang optimal
- Data Manipulation: Penggunaan pandas operations seperti loc, drop, merge, dan head untuk data processing
Score Integration: List comprehension untuk menambahkan similarity score ke hasil akhir
- Return Handling: Mengembalikan error message untuk anime tidak ditemukan atau DataFrame untuk hasil valid
- Modular Design: Fungsi dapat digunakan dengan berbagai similarity matrix dan anime dataset yang berbeda
"""

def get_anime_recommendations(anime_title, similarity_data=similarity_df, anime_data=df[['Title', 'Genres', 'Score']], num_recommendations=5):
    # Mengecek apakah anime ada dalam dataset
    if anime_title not in similarity_data.index:
        return f"Anime '{anime_title}' tidak ditemukan dalam dataset"

    # Mengambil nilai similarity dan mengurutkannya
    similarity_scores = similarity_data.loc[anime_title].to_numpy()

    # Menggunakan argpartition untuk mendapatkan index dengan similarity tertinggi
    top_indices = similarity_scores.argpartition(range(-1, -num_recommendations-1, -1))

    # Mengambil anime dengan similarity tertinggi
    most_similar_indices = top_indices[-1:-(num_recommendations+2):-1]
    recommended_titles = similarity_data.columns[most_similar_indices]

    # Menghapus anime input agar tidak muncul dalam rekomendasi
    recommended_titles = recommended_titles.drop(anime_title, errors='ignore')

    # Menggabungkan dengan informasi anime lengkap
    recommendations = pd.DataFrame(recommended_titles, columns=['Title']).merge(
        anime_data, on='Title', how='left'
    ).head(num_recommendations)

    # Menambahkan kolom similarity score
    recommendations['Similarity_Score'] = [similarity_data.loc[anime_title, title] for title in recommendations['Title']]

    return recommendations

"""#### Top 5 Recommendation

Untuk menjalankan kodenya cukup mengisi judul anime yang diinginkan dan memanggil fungsi get_anime_recommendations() seperti contoh dibawah
"""

get_anime_recommendations('Shingeki no Kyojin')

"""## Evaluation

### Evaluasi Hasil

Evaluasi model yang dilakukan untuk prediksi data ini menggunakan metrik berupa ***Cosine Similarity dan Avarage Genre Similarity***

| **Aspek**                | **Penjelasan**                                                                                      |
|--------------------------|-----------------------------------------------------------------------------------------------------|
| **Cosine Similarity**    | Mengukur kesamaan genre antara anime target dengan anime yang direkomendasikan.                 |
|                          | Range nilai: 0-1 (0 = tidak mirip, 1 = identik).                                                   |
|                          | Dihitung menggunakan `cosine_similarity(target_vector, vectors_rec)`.                            |
| **Average Genre Similarity** | Rata-rata cosine similarity dari semua rekomendasi yang diberikan.                          |
|                          | Dikonversi ke persentase untuk interpretasi yang lebih mudah.                                      |
|                          | menggunakan fungsi `genre_similarities.mean() * 100`.                                                          |
| **Kelebihan**            | Sesuai dengan problem statement (rekomendasi berdasarkan genre).                                |
|                          | Mudah diinterpretasi.                                                                               |
|                          | Memberikan feedback langsung tentang kualitas sistem.                                               |
| **Keterbatasan**         | Hanya fokus pada genre, tidak mempertimbangkan rating atau popularitas.                         |
|                          | Tidak ada ground truth untuk validasi objektif.                                                     |

pada tahapan evaluasi disini saya membuat fungsi yang dinakakan`evaluate_recommendations()` untuk mengevaluasi kualitas rekomendasi anime dan mendapat persentase akurasi dari judul anime yang direkomendasikan oleh sistem.


Fungsi mengambil vektor TF-IDF dari anime target, mendapatkan rekomendasi menggunakan fungsi sebelumnya, lalu menghitung similarity score antara anime target dengan setiap rekomendasi menggunakan `cosine_similarity()`. Hasilnya ditampilkan dalam bentuk DataFrame dengan kolom tambahan 'Genre_Similarity' dan rata-rata similarity sebagai indikator akurasi rekomendasi
"""

def evaluate_recommendations(anime_title, tfidf_matrix, df, similarity_df):
    if anime_title not in df['Title'].values:
        return f"Anime '{anime_title}' tidak ditemukan dalam dataset."

    # Ambil index & vektor TF-IDF dari anime target
    idx_target = df[df['Title'] == anime_title].index[0]
    target_vector = tfidf_matrix[idx_target]

    # Dapatkan rekomendasi
    recommendations = get_anime_recommendations(anime_title, similarity_data=similarity_df, anime_data=df[['Title', 'Genres', 'Score']], num_recommendations=5)

    # Filter out jika rekomendasi kosong atau semua dari seri/franchise yang sama
    if recommendations.empty:
        return "Rekomendasi kosong."

    # Ambil index rekomendasi dalam tfidf_matrix
    indices_rec = df[df['Title'].isin(recommendations['Title'])].index
    vectors_rec = tfidf_matrix[indices_rec]

    # Hitung cosine similarity genre antar vektor
    genre_similarities = cosine_similarity(target_vector, vectors_rec)[0]

    # Tambahkan skor ke dataframe hasil
    recommendations['Genre_Similarity'] = [round(score, 2) for score in genre_similarities]

    # Hitung rata-rata similarity sebagai "akurasi"
    average_score = round(genre_similarities.mean() * 100, 2)
    print(f" Genre Similarity Average: {average_score}%")

    return recommendations

"""Untuk menjalankan kodenya cukup mengisi judul anime yang diinginkan dan memanggil fungsi evaluate_recommendations("Judul Anime", tfidf_matrix, df, similarity_df) seperti contoh dibawah"""

evaluate_recommendations("Shingeki no Kyojin", tfidf_matrix, df, similarity_df)

"""## Kesimpulan

Model sistem rekomendasi anime yang dikembangkan telah berhasil menjawab seluruh problem statement dan mencapai goals yang ditetapkan. Dari keseluruhan implementasi, **TF-IDF Vectorizer dengan Cosine Similarity** merupakan pendekatan terbaik untuk diterapkan pada dataset anime ini karena memiliki tingkat akurasi rekomendasi yang sangat tinggi, yaitu **Genre Similarity Average sebesar 85.6%** dan **Similarity Score konsisten di atas 0.82** untuk semua rekomendasi.
Secara keseluruhan, evaluasi menunjukkan bahwa solusi content-based filtering yang diimplementasikan berdampak positif terhadap kualitas rekomendasi dan relevansi hasil yang diberikan kepada pengguna, serta layak digunakan sebagai alat bantu dalam sistem rekomendasi anime berbasis kesamaan genre di platform streaming atau database anime.
"""